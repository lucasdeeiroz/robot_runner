import React, { useMemo, useState, useRef, useEffect } from 'react';
import { createPortal } from 'react-dom';
import { ScreenMap, FlowchartLayout } from '@/lib/types';
import { X, ZoomIn, ZoomOut, Maximize, Pencil, Save } from 'lucide-react';
import { useTranslation } from 'react-i18next';
import clsx from 'clsx';
import { saveFlowchartLayout, loadFlowchartLayout } from '@/lib/dashboard/mapperPersistence';
import { feedback } from '@/lib/feedback';

interface FlowchartModalProps {
    isOpen: boolean;
    onClose: () => void;
    maps: ScreenMap[];
    onEditScreen?: (screenName: string) => void;
    activeProfileId: string;
}

// --- Constants ---
const CELL_WIDTH = 300;
const CELL_HEIGHT = 400;
const NODE_WIDTH = 220;
const NODE_HEIGHT = 280;
const LANE_SIZE = 20;

// Grid offsets to center node in cell
const NODE_OFFSET_X = (CELL_WIDTH - NODE_WIDTH) / 2;
const NODE_OFFSET_Y = (CELL_HEIGHT - NODE_HEIGHT) / 2;

// Port Configuration
const PORTS_TOP = 5;
const PORTS_BOTTOM = 5;
const PORTS_LEFT = 7;
const PORTS_RIGHT = 7;

type Side = 'top' | 'bottom' | 'left' | 'right';

interface Port {
    id: string; // "top-0", "left-3"
    side: Side;
    index: number;
    x: number; // Relative to node
    y: number;
}

// Generate Ports for a generic node
const generatePorts = (): Port[] => {
    const ports: Port[] = [];

    // Top (0 to 4)
    const stepX = NODE_WIDTH / (PORTS_TOP + 1);
    for (let i = 0; i < PORTS_TOP; i++) {
        ports.push({ id: `top-${i}`, side: 'top', index: i, x: stepX * (i + 1), y: 0 });
    }

    // Bottom (0 to 4)
    for (let i = 0; i < PORTS_BOTTOM; i++) {
        ports.push({ id: `bottom-${i}`, side: 'bottom', index: i, x: stepX * (i + 1), y: NODE_HEIGHT });
    }

    // Left (0 to 6)
    const stepY = NODE_HEIGHT / (PORTS_LEFT + 1);
    for (let i = 0; i < PORTS_LEFT; i++) {
        ports.push({ id: `left-${i}`, side: 'left', index: i, x: 0, y: stepY * (i + 1) });
    }

    // Right (0 to 6)
    for (let i = 0; i < PORTS_RIGHT; i++) {
        ports.push({ id: `right-${i}`, side: 'right', index: i, x: NODE_WIDTH, y: stepY * (i + 1) });
    }

    return ports;
};

const NODE_PORTS = generatePorts();


export function FlowchartModal({ isOpen, onClose, maps, onEditScreen, activeProfileId }: FlowchartModalProps) {
    const { t } = useTranslation();
    const [scale, setScale] = useState(1);
    const [offset, setOffset] = useState({ x: 0, y: 0 });
    const [isDraggingCanvas, setIsDraggingCanvas] = useState(false);
    const containerRef = useRef<HTMLDivElement>(null);
    const dragStart = useRef({ x: 0, y: 0 });

    // Layout State
    const [layout, setLayout] = useState<FlowchartLayout>({ version: 1, nodes: {}, edges: {} });
    const [loading, setLoading] = useState(true);

    // Interaction State
    // Interaction State
    // draggedNode was unused, removed.
    // Drag types: 'node', 'vertex', 'source', 'target', 'segment'
    const [dragItem, setDragItem] = useState<{
        type: 'node' | 'vertex' | 'source' | 'target' | 'segment';
        id: string; // Node Name or Edge ID
        index?: number;
        points?: { x: number, y: number }[]; // Snapshot of points for segment dragging
    } | null>(null);

    // For rendering potential connections
    const [hoveredPort, setHoveredPort] = useState<{ nodeId: string, portId: string } | null>(null);


    // Load Layout
    useEffect(() => {
        if (isOpen) {
            loadLayout();
        }
    }, [isOpen, activeProfileId]);

    const loadLayout = async () => {
        setLoading(true);
        const saved = await loadFlowchartLayout(activeProfileId);
        if (saved) {
            setLayout(saved);
        } else {
            setLayout({ version: 1, nodes: {}, edges: {} });
        }
        setLoading(false);
    };

    const saveLayout = async () => {
        await saveFlowchartLayout(activeProfileId, layout);
        feedback.toast.success(t('common.saved', 'Saved'));
    };

    // Auto-Layout New Nodes
    useEffect(() => {
        if (loading) return;

        let hasChanges = false;
        const newNodes = { ...layout.nodes };
        const occupied = new Set<string>();
        Object.values(newNodes).forEach(n => occupied.add(`${n.gridX},${n.gridY}`));

        let nextX = 0;
        let nextY = 0;

        maps.forEach(map => {
            if (!newNodes[map.name]) {
                while (occupied.has(`${nextX},${nextY}`)) {
                    nextX++;
                    if (nextX > 5) {
                        nextX = 0;
                        nextY++;
                    }
                }
                newNodes[map.name] = { gridX: nextX, gridY: nextY };
                occupied.add(`${nextX},${nextY}`);
                hasChanges = true;
            }
        });

        if (hasChanges) {
            setLayout(prev => ({ ...prev, nodes: newNodes }));
        }
    }, [maps, loading]);


    // --- Helper Functions ---

    const getPixelCoords = (gridX: number, gridY: number) => ({
        x: gridX * CELL_WIDTH + NODE_OFFSET_X,
        y: gridY * CELL_HEIGHT + NODE_OFFSET_Y
    });

    const getPortCoords = (nodeX: number, nodeY: number, portId: string) => {
        const port = NODE_PORTS.find(p => p.id === portId);
        if (!port) return { x: nodeX + NODE_WIDTH / 2, y: nodeY + NODE_HEIGHT / 2 }; // Center fallback
        return { x: nodeX + port.x, y: nodeY + port.y };
    };

    const snapToLanes = (x: number, y: number) => {
        return {
            x: Math.round(x / LANE_SIZE) * LANE_SIZE,
            y: Math.round(y / LANE_SIZE) * LANE_SIZE
        };
    };

    const getClosestLane = (val: number) => Math.round(val / LANE_SIZE) * LANE_SIZE;


    // --- Event Handlers ---

    const handleCanvasMouseDown = (e: React.MouseEvent) => {
        if (e.button !== 0) return;
        setIsDraggingCanvas(true);
        dragStart.current = { x: e.clientX - offset.x, y: e.clientY - offset.y };
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!containerRef.current) return;

        // Canvas Panning
        if (isDraggingCanvas) {
            setOffset({
                x: e.clientX - dragStart.current.x,
                y: e.clientY - dragStart.current.y
            });
            return;
        }

        const rect = containerRef.current.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - offset.x) / scale;
        const mouseY = (e.clientY - rect.top - offset.y) / scale;

        // Node Dragging
        if (dragItem?.type === 'node') {
            const gridX = Math.round((mouseX - NODE_OFFSET_X) / CELL_WIDTH);
            const gridY = Math.round((mouseY - NODE_OFFSET_Y) / CELL_HEIGHT);

            setLayout(prev => ({
                ...prev,
                nodes: {
                    ...prev.nodes,
                    [dragItem.id]: { gridX: Math.max(0, gridX), gridY: Math.max(0, gridY) }
                }
            }));
        }

        // Edge Dragging (Vertex, Source, Target, Segment)
        if (dragItem?.type === 'vertex' || dragItem?.type === 'source' || dragItem?.type === 'target' || dragItem?.type === 'segment') {
            // Lane Snapping for Vertices
            let snapped = { x: mouseX, y: mouseY };

            // If dragging a vertex, we might want 4-lane logic (snap to grid lines)
            if (dragItem.type === 'vertex') {
                snapped = snapToLanes(mouseX, mouseY);
            }

            // Segment Dragging
            if (dragItem.type === 'segment' && dragItem.points && typeof dragItem.index === 'number') {
                const { points, index, id: edgeId } = dragItem;

                const p1 = points[index];
                const p2 = points[index + 1];
                const isHorizontal = Math.abs(p1.y - p2.y) < 1;

                const snappedX = getClosestLane(mouseX);
                const snappedY = getClosestLane(mouseY);

                setLayout(prev => {
                    const prevEdge = prev.edges[edgeId] || {};
                    let newVertices: { x: number, y: number }[] = [];

                    // If no vertices yet, we are creating them from the default path snapshot
                    if (!prevEdge.vertices || prevEdge.vertices.length === 0) {
                        const currentPoints = points.map(p => ({ ...p })); // Deep copy

                        if (isHorizontal && index > 0 && index < points.length - 1) {
                            currentPoints[index].y = snappedY;
                            currentPoints[index + 1].y = snappedY;
                        } else if (!isHorizontal && index > 0 && index < points.length - 1) {
                            currentPoints[index].x = snappedX;
                            currentPoints[index + 1].x = snappedX;
                        }

                        // Helper: If dragging the first segment (0), we can't really move it if start is fixed.
                        // But if we are in a 3-segment orthogonal router, dragging the middle one is common.
                        // For now, let's just support dragging existing vertices or converting default path to vertices.

                        // Since we don't have a complex orthogonal router, let's just return for now if no vertices,
                        // OR implement a simple "split and move" later.
                        // The user asked for dragging segments.
                        // The simplest way is: defined vertices.

                        newVertices = currentPoints.slice(1, -1);
                    } else {
                        newVertices = [...prevEdge.vertices];
                        // Map segment index to vertex index
                        // Segment i connects points[i] and points[i+1]
                        // points[0] = Start (Fixed)
                        // points[1] = Vertex 0
                        // points[2] = Vertex 1 ...

                        // If dragging Segment 1 (Vertex 0 -> Vertex 1):
                        // We update Vertex 0 and Vertex 1 coords.

                        if (isHorizontal) {
                            if (index - 1 >= 0) newVertices[index - 1] = { ...newVertices[index - 1], y: snappedY };
                            if (index < newVertices.length) newVertices[index] = { ...newVertices[index], y: snappedY };
                        } else {
                            if (index - 1 >= 0) newVertices[index - 1] = { ...newVertices[index - 1], x: snappedX };
                            if (index < newVertices.length) newVertices[index] = { ...newVertices[index], x: snappedX };
                        }
                    }

                    return {
                        ...prev,
                        edges: {
                            ...prev.edges,
                            [edgeId]: { ...prevEdge, vertices: newVertices }
                        }
                    };
                });
                return;
            }

            // Update Layout temporarily for feedback (Vertex/Handles)
            setLayout(prev => {
                const edgeId = dragItem.id;
                const edge = prev.edges[edgeId] || { vertices: [] };

                if (dragItem.type === 'vertex' && typeof dragItem.index === 'number') {
                    const newVertices = [...(edge.vertices || [])];
                    if (newVertices[dragItem.index]) {
                        newVertices[dragItem.index] = snapped;
                    }
                    return { ...prev, edges: { ...prev.edges, [edgeId]: { ...edge, vertices: newVertices } } };
                }
                return prev;
            });
        }
    };

    const handleMouseUp = () => {
        if (dragItem?.type === 'source' || dragItem?.type === 'target') {
            if (hoveredPort) {
                // Check if port is occupied
                const isOccupied = Object.entries(layout.edges).some(([eKey, edge]) => {
                    // Check if ANY edge uses this port on this node
                    // This mimics the logic in render
                    const [sName, _, tName] = eKey.split('-');
                    // IMPORTANT: We must NOT block if the edge occupying it is the ONE WE ARE DRAGGING (dragItem.id)
                    if (eKey === dragItem.id) return false;

                    if (sName === hoveredPort.nodeId && edge.sourceHandle === hoveredPort.portId) return true;
                    if (tName === hoveredPort.nodeId && edge.targetHandle === hoveredPort.portId) return true;
                    return false;
                });

                if (!isOccupied) {
                    setLayout(prev => ({
                        ...prev, // Keep prev layout
                        edges: {
                            ...prev.edges,
                            [dragItem.id]: {
                                ...prev.edges[dragItem.id],
                                [dragItem.type === 'source' ? 'sourceHandle' : 'targetHandle']: hoveredPort.portId
                            }
                        }
                    }));
                } else {
                    feedback.toast.error("Port already occupied");
                }
            }
        }

        setIsDraggingCanvas(false);
        setDragItem(null);
    };

    const handleWheel = (e: React.WheelEvent) => {
        e.stopPropagation();
        if (e.ctrlKey || e.metaKey) {
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            setScale(s => Math.min(Math.max(s * delta, 0.1), 3));
        }
    };


    // --- Render Logic ---

    const renderEdges = useMemo(() => {
        const rendered: React.ReactNode[] = [];

        maps.forEach(sourceMap => {
            const sourceLayout = layout.nodes[sourceMap.name];
            if (!sourceLayout) return;
            const sourceOrigin = getPixelCoords(sourceLayout.gridX, sourceLayout.gridY);

            sourceMap.elements.forEach(el => {
                const targetName = el.navigates_to;
                if (!targetName) return;

                const targetMap = maps.find(m => m.name === targetName);
                const targetLayout = layout.nodes[targetName];
                if (!targetMap || !targetLayout) return;

                const targetOrigin = getPixelCoords(targetLayout.gridX, targetLayout.gridY);
                const edgeId = `${sourceMap.name}-${el.name}-${targetName}`;
                const edgeData = layout.edges[edgeId] || {};

                // Determine Start/End Points
                // 1. If Handle defined, use it.
                // 2. Else calculate default based on relative position.

                let startPoint = { x: 0, y: 0 };
                let endPoint = { x: 0, y: 0 };

                // Source
                if (edgeData.sourceHandle) {
                    startPoint = getPortCoords(sourceOrigin.x, sourceOrigin.y, edgeData.sourceHandle);
                } else {
                    // Default Source: Right side usually, or closest side
                    const dx = targetLayout.gridX - sourceLayout.gridX;
                    if (dx >= 0) startPoint = getPortCoords(sourceOrigin.x, sourceOrigin.y, 'right-3'); // Middle Right
                    else startPoint = getPortCoords(sourceOrigin.x, sourceOrigin.y, 'left-3');
                }

                // Target
                if (edgeData.targetHandle) {
                    endPoint = getPortCoords(targetOrigin.x, targetOrigin.y, edgeData.targetHandle);
                } else {
                    const dx = targetLayout.gridX - sourceLayout.gridX;
                    if (dx >= 0) endPoint = getPortCoords(targetOrigin.x, targetOrigin.y, 'left-3');
                    else endPoint = getPortCoords(targetOrigin.x, targetOrigin.y, 'right-3');
                }

                // Vertices
                // If dragging a "source" or "target", we might overlay a line to mouse.
                // For now, just render the stored path.

                let points = [startPoint, ...(edgeData.vertices || []), endPoint];

                // If default path needed (no vertices) -> Manual Orthogonal Logic?
                if ((!edgeData.vertices || edgeData.vertices.length === 0)) {
                    const midX = (startPoint.x + endPoint.x) / 2;
                    // Snap midX to lane?
                    const snappedMidX = getClosestLane(midX);
                    points = [startPoint, { x: snappedMidX, y: startPoint.y }, { x: snappedMidX, y: endPoint.y }, endPoint];
                }

                // Path construction
                // Instead of one path, we render segments for interaction
                const segments: React.ReactNode[] = [];
                let d = `M ${points[0].x} ${points[0].y}`;

                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    d += ` L ${p2.x} ${p2.y}`;

                    // Determine segment orientation
                    const isHorizontal = Math.abs(p1.y - p2.y) < 1;
                    // isVertical unused

                    // Hit box for segment
                    segments.push(
                        <line
                            key={`${edgeId}-seg-${i}`}
                            x1={p1.x} y1={p1.y}
                            x2={p2.x} y2={p2.y}
                            stroke="transparent"
                            strokeWidth={15}
                            className={clsx(
                                "cursor-pointer pointer-events-auto",
                                isHorizontal ? "cursor-row-resize" : "cursor-col-resize"
                            )}
                            onMouseDown={(e) => {
                                e.stopPropagation();
                                setDragItem({ type: 'segment', id: edgeId, index: i, points: points });
                            }}
                        />
                    );
                }

                // Render
                rendered.push(
                    <g key={edgeId} className="group/edge pointer-events-auto">
                        {/* The visible path */}
                        <path d={d} stroke="#9ca3af" strokeWidth={2} fill="none" markerEnd="url(#arrowhead)"
                            className="group-hover/edge:stroke-primary transition-colors pointer-events-none" />

                        {/* Segment Hit Boxes (Invisible) */}
                        {segments}

                        {/* Label */}
                        {points.length >= 2 && (
                            <foreignObject x={(points[0].x + points[1].x) / 2 - 60} y={(points[0].y + points[1].y) / 2 - 12} width={120} height={24}>
                                <div className="bg-surface/90 text-on-surface text-[10px] px-2 py-0.5 rounded-full text-center truncate border border-outline-variant/50 shadow-sm pointer-events-auto select-none group-hover/edge:border-primary group-hover/edge:text-primary transition-colors cursor-move"
                                    onMouseDown={() => {
                                        // Allow label label dragging feature? 
                                        // For now just pass thru or maybe auto-select edge
                                    }}>
                                    {el.name}
                                </div>
                            </foreignObject>
                        )}

                        {/* Interactive Handles */}

                        {/* Source Handle */}
                        <circle cx={startPoint.x} cy={startPoint.y} r={6} fill="transparent" className="cursor-grab hover:fill-primary/50 pointer-events-auto"
                            onMouseDown={(e) => { e.stopPropagation(); setDragItem({ type: 'source', id: edgeId }); }} />

                        {/* Target Handle */}
                        <circle cx={endPoint.x} cy={endPoint.y} r={6} fill="transparent" className="cursor-grab hover:fill-primary/50 pointer-events-auto"
                            onMouseDown={(e) => { e.stopPropagation(); setDragItem({ type: 'target', id: edgeId }); }} />

                        {/* Vertices */}
                        {points.slice(1, -1).map((p, idx) => (
                            <circle key={`${edgeId}-v-${idx}`} cx={p.x} cy={p.y} r={5} fill="#3b82f6" className="cursor-move opacity-0 group-hover/edge:opacity-100 pointer-events-auto"
                                onMouseDown={(e) => { e.stopPropagation(); setDragItem({ type: 'vertex', id: edgeId, index: idx }); }} />
                        ))}

                    </g>
                );
            });
        });

        return rendered;
    }, [maps, layout, hoveredPort]);


    // Load Layout
    useEffect(() => {
        if (isOpen) {
            loadLayout();
        }
    }, [isOpen, activeProfileId]);

    const loadLayout = async () => {
        setLoading(true);
        const saved = await loadFlowchartLayout(activeProfileId);
        if (saved) {
            setLayout(saved);
        } else {
            setLayout({ version: 1, nodes: {}, edges: {} });
        }
        setLoading(false);
    };

    const saveLayout = async () => {
        await saveFlowchartLayout(activeProfileId, layout);
        feedback.toast.success(t('common.saved', 'Saved'));
    };

    // Auto-Layout New Nodes
    useEffect(() => {
        if (loading) return;

        let hasChanges = false;
        const newNodes = { ...layout.nodes };
        const occupied = new Set<string>();
        Object.values(newNodes).forEach(n => occupied.add(`${n.gridX},${n.gridY}`));

        let nextX = 0;
        let nextY = 0;

        maps.forEach(map => {
            if (!newNodes[map.name]) {
                while (occupied.has(`${nextX},${nextY}`)) {
                    nextX++;
                    if (nextX > 5) {
                        nextX = 0;
                        nextY++;
                    }
                }
                newNodes[map.name] = { gridX: nextX, gridY: nextY };
                occupied.add(`${nextX},${nextY}`);
                hasChanges = true;
            }
        });

        if (hasChanges) {
            setLayout(prev => ({ ...prev, nodes: newNodes }));
        }
    }, [maps, loading]);


    // --- Helper Functions ---

    const getPixelCoords = (gridX: number, gridY: number) => ({
        x: gridX * CELL_WIDTH + NODE_OFFSET_X,
        y: gridY * CELL_HEIGHT + NODE_OFFSET_Y
    });

    const getPortCoords = (nodeX: number, nodeY: number, portId: string) => {
        const port = NODE_PORTS.find(p => p.id === portId);
        if (!port) return { x: nodeX + NODE_WIDTH / 2, y: nodeY + NODE_HEIGHT / 2 }; // Center fallback
        return { x: nodeX + port.x, y: nodeY + port.y };
    };

    const snapToLanes = (x: number, y: number) => {
        return {
            x: Math.round(x / LANE_SIZE) * LANE_SIZE,
            y: Math.round(y / LANE_SIZE) * LANE_SIZE
        };
    };

    const getClosestLane = (val: number) => Math.round(val / LANE_SIZE) * LANE_SIZE;


    // --- Event Handlers ---

    const handleCanvasMouseDown = (e: React.MouseEvent) => {
        if (e.button !== 0) return;
        setIsDraggingCanvas(true);
        dragStart.current = { x: e.clientX - offset.x, y: e.clientY - offset.y };
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!containerRef.current) return;

        // Canvas Panning
        if (isDraggingCanvas) {
            setOffset({
                x: e.clientX - dragStart.current.x,
                y: e.clientY - dragStart.current.y
            });
            return;
        }

        const rect = containerRef.current.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - offset.x) / scale;
        const mouseY = (e.clientY - rect.top - offset.y) / scale;

        // Node Dragging
        if (dragItem?.type === 'node') {
            const gridX = Math.round((mouseX - NODE_OFFSET_X) / CELL_WIDTH);
            const gridY = Math.round((mouseY - NODE_OFFSET_Y) / CELL_HEIGHT);

            setLayout(prev => ({
                ...prev,
                nodes: {
                    ...prev.nodes,
                    [dragItem.id]: { gridX: Math.max(0, gridX), gridY: Math.max(0, gridY) }
                }
            }));
        }

        // Edge Dragging (Vertex, Source, Target)
        if (dragItem?.type === 'vertex' || dragItem?.type === 'source' || dragItem?.type === 'target') {
            // Lane Snapping for Vertices
            let snapped = { x: mouseX, y: mouseY };

            // If dragging a vertex, we might want 4-lane logic (snap to grid lines)
            if (dragItem.type === 'vertex') {
                snapped = snapToLanes(mouseX, mouseY);
            }

            // Update Layout temporarily for feedback
            setLayout(prev => {
                const edgeId = dragItem.id;
                const edge = prev.edges[edgeId] || { vertices: [] };

                if (dragItem.type === 'vertex' && typeof dragItem.index === 'number') {
                    const newVertices = [...(edge.vertices || [])];
                    // Ensure vertices exist up to this point? 
                    // Actually, if we are dragging an existing vertex, it exists.
                    if (newVertices[dragItem.index]) {
                        newVertices[dragItem.index] = snapped;
                    }
                    return { ...prev, edges: { ...prev.edges, [edgeId]: { ...edge, vertices: newVertices } } };
                }

                // For handles, we don't update layout *position* directly in real-time if we want to snap to ports.
                // We just let the mouse move, and rely on `hoveredPort` highlighting.
                // But we CAN render a "drag line" if we wanted. 
                // For now, let's strictly handle dropping on `handleMouseUp`.
                return prev;
            });
        }
    };

    const handleMouseUp = () => {
        if (dragItem?.type === 'source' || dragItem?.type === 'target') {
            if (hoveredPort) {
                // Check if port is occupied
                const isOccupied = Object.entries(layout.edges).some(([eKey, edge]) => {
                    // Check if ANY edge uses this port on this node
                    // This mimics the logic in render
                    const [sName, _, tName] = eKey.split('-');
                    // IMPORTANT: We must NOT block if the edge occupying it is the ONE WE ARE DRAGGING (dragItem.id)
                    if (eKey === dragItem.id) return false;

                    if (sName === hoveredPort.nodeId && edge.sourceHandle === hoveredPort.portId) return true;
                    if (tName === hoveredPort.nodeId && edge.targetHandle === hoveredPort.portId) return true;
                    return false;
                });

                if (!isOccupied) {
                    setLayout(prev => ({
                        ...prev, // Keep prev layout
                        edges: {
                            ...prev.edges,
                            [dragItem.id]: {
                                ...prev.edges[dragItem.id],
                                [dragItem.type === 'source' ? 'sourceHandle' : 'targetHandle']: hoveredPort.portId
                            }
                        }
                    }));
                } else {
                    feedback.toast.error("Port already occupied");
                }
            }
        }

        setIsDraggingCanvas(false);
        setDragItem(null);
    };

    const handleWheel = (e: React.WheelEvent) => {
        e.stopPropagation();
        if (e.ctrlKey || e.metaKey) {
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            setScale(s => Math.min(Math.max(s * delta, 0.1), 3));
        }
    };


    // --- Render Logic ---

    const renderEdges = useMemo(() => {
        const rendered: React.ReactNode[] = [];

        maps.forEach(sourceMap => {
            const sourceLayout = layout.nodes[sourceMap.name];
            if (!sourceLayout) return;
            const sourceOrigin = getPixelCoords(sourceLayout.gridX, sourceLayout.gridY);

            sourceMap.elements.forEach(el => {
                const targetName = el.navigates_to;
                if (!targetName) return;

                const targetMap = maps.find(m => m.name === targetName);
                const targetLayout = layout.nodes[targetName];
                if (!targetMap || !targetLayout) return;

                const targetOrigin = getPixelCoords(targetLayout.gridX, targetLayout.gridY);
                const edgeId = `${sourceMap.name}-${el.name}-${targetName}`;
                const edgeData = layout.edges[edgeId] || {};

                // Determine Start/End Points
                // 1. If Handle defined, use it.
                // 2. Else calculate default based on relative position.

                let startPoint = { x: 0, y: 0 };
                let endPoint = { x: 0, y: 0 };

                // Source
                if (edgeData.sourceHandle) {
                    startPoint = getPortCoords(sourceOrigin.x, sourceOrigin.y, edgeData.sourceHandle);
                } else {
                    // Default Source: Right side usually, or closest side
                    const dx = targetLayout.gridX - sourceLayout.gridX;
                    if (dx >= 0) startPoint = getPortCoords(sourceOrigin.x, sourceOrigin.y, 'right-3'); // Middle Right
                    else startPoint = getPortCoords(sourceOrigin.x, sourceOrigin.y, 'left-3');
                }

                // Target
                if (edgeData.targetHandle) {
                    endPoint = getPortCoords(targetOrigin.x, targetOrigin.y, edgeData.targetHandle);
                } else {
                    const dx = targetLayout.gridX - sourceLayout.gridX;
                    if (dx >= 0) endPoint = getPortCoords(targetOrigin.x, targetOrigin.y, 'left-3');
                    else endPoint = getPortCoords(targetOrigin.x, targetOrigin.y, 'right-3');
                }

                // Vertices
                // If dragging a "source" or "target", we might overlay a line to mouse.
                // For now, just render the stored path.

                let points = [startPoint, ...(edgeData.vertices || []), endPoint];

                // If default path needed (no vertices) -> Manual Orthogonal Logic?
                if ((!edgeData.vertices || edgeData.vertices.length === 0)) {
                    const midX = (startPoint.x + endPoint.x) / 2;
                    // Snap midX to lane?
                    const snappedMidX = getClosestLane(midX);
                    points = [startPoint, { x: snappedMidX, y: startPoint.y }, { x: snappedMidX, y: endPoint.y }, endPoint];
                }

                // Path construction
                // Instead of one path, we render segments for interaction
                const segments: React.ReactNode[] = [];
                let d = `M ${points[0].x} ${points[0].y}`;

                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    d += ` L ${p2.x} ${p2.y}`;

                    // Determine segment orientation
                    const isHorizontal = Math.abs(p1.y - p2.y) < 1;
                    const isVertical = Math.abs(p1.x - p2.x) < 1;

                    // Hit box for segment
                    segments.push(
                        <line
                            key={`${edgeId}-seg-${i}`}
                            x1={p1.x} y1={p1.y}
                            x2={p2.x} y2={p2.y}
                            stroke="transparent"
                            strokeWidth={15}
                            className={clsx(
                                "cursor-pointer pointer-events-auto",
                                isHorizontal ? "cursor-row-resize" : "cursor-col-resize"
                            )}
                            onMouseDown={(e) => {
                                e.stopPropagation();
                                setDragItem({ type: 'segment', id: edgeId, index: i, points: points });
                            }}
                        />
                    );
                }

                // Render
                rendered.push(
                    <g key={edgeId} className="group/edge pointer-events-auto">
                        {/* The visible path */}
                        <path d={d} stroke="#9ca3af" strokeWidth={2} fill="none" markerEnd="url(#arrowhead)"
                            className="group-hover/edge:stroke-primary transition-colors pointer-events-none" />

                        {/* Segment Hit Boxes (Invisible) */}
                        {segments}

                        {/* Label */}
                        {points.length >= 2 && (
                            <foreignObject x={(points[0].x + points[1].x) / 2 - 60} y={(points[0].y + points[1].y) / 2 - 12} width={120} height={24}>
                                <div className="bg-surface/90 text-on-surface text-[10px] px-2 py-0.5 rounded-full text-center truncate border border-outline-variant/50 shadow-sm pointer-events-auto select-none group-hover/edge:border-primary group-hover/edge:text-primary transition-colors cursor-move"
                                    onMouseDown={() => {
                                        // Allow label label dragging feature? 
                                        // For now just pass thru or maybe auto-select edge
                                    }}>
                                    {el.name}
                                </div>
                            </foreignObject>
                        )}

                        {/* Interactive Handles */}

                        {/* Source Handle */}
                        <circle cx={startPoint.x} cy={startPoint.y} r={6} fill="transparent" className="cursor-grab hover:fill-primary/50 pointer-events-auto"
                            onMouseDown={(e) => { e.stopPropagation(); setDragItem({ type: 'source', id: edgeId }); }} />

                        {/* Target Handle */}
                        <circle cx={endPoint.x} cy={endPoint.y} r={6} fill="transparent" className="cursor-grab hover:fill-primary/50 pointer-events-auto"
                            onMouseDown={(e) => { e.stopPropagation(); setDragItem({ type: 'target', id: edgeId }); }} />

                        {/* Vertices */}
                        {points.slice(1, -1).map((p, idx) => (
                            <circle key={`${edgeId}-v-${idx}`} cx={p.x} cy={p.y} r={5} fill="#3b82f6" className="cursor-move opacity-0 group-hover/edge:opacity-100 pointer-events-auto"
                                onMouseDown={(e) => { e.stopPropagation(); setDragItem({ type: 'vertex', id: edgeId, index: idx }); }} />
                        ))}

                    </g>
                );
            });
        });

        return rendered;
    }, [maps, layout, hoveredPort]);


    if (!isOpen) return null;


    return createPortal(
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/50 backdrop-blur-sm animate-in fade-in duration-200">
            <div className="bg-surface w-[90vw] h-[90vh] rounded-2xl shadow-2xl flex flex-col overflow-hidden border border-outline-variant/30">
                {/* Header */}
                <div className="flex items-center justify-between px-6 py-4 border-b border-outline-variant/30 bg-surface">
                    <h2 className="text-lg font-semibold text-on-surface flex items-center gap-2">
                        <Maximize className="text-primary" size={20} />
                        {t('mapper.flowchart.title', 'Navigation Flow')}
                        <span className="text-xs font-normal text-on-surface-variant/50 ml-2">(Enhanced)</span>
                    </h2>
                    <div className="flex items-center gap-2">
                        <button onClick={saveLayout} className="p-2 hover:bg-primary/10 text-primary rounded-full" title={t('common.save')}>
                            <Save size={20} />
                        </button>
                        <div className="h-6 w-px bg-outline-variant/30 mx-2" />
                        <div className="flex bg-surface-variant/30 rounded-lg p-1 mr-4">
                            <button onClick={() => setScale(s => s - 0.1)} className="p-1.5 hover:bg-surface/50 rounded text-on-surface-variant"><ZoomOut size={16} /></button>
                            <span className="px-2 text-xs flex items-center text-on-surface-variant/80 min-w-[3rem] justify-center">{Math.round(scale * 100)}%</span>
                            <button onClick={() => setScale(s => s + 0.1)} className="p-1.5 hover:bg-surface/50 rounded text-on-surface-variant"><ZoomIn size={16} /></button>
                        </div>
                        <button onClick={onClose} className="p-2 hover:bg-error/10 hover:text-error rounded-full transition-colors text-on-surface/60"><X size={20} /></button>
                    </div>
                </div>

                {/* Canvas */}
                <div
                    ref={containerRef}
                    className="flex-1 overflow-hidden relative bg-surface-variant/5 cursor-move"
                    onMouseDown={handleCanvasMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    onWheel={handleWheel}
                    data-bg="true"
                >
                    <div
                        className="absolute origin-top-left transition-transform duration-75"
                        style={{
                            transform: `translate(${offset.x}px, ${offset.y}px) scale(${scale})`,
                            width: 3000,
                            height: 3000
                        }}
                    >
                        {/* Grid Background */}
                        <div className="absolute inset-0 pointer-events-none"
                            style={{
                                zIndex: 0,
                                backgroundImage: `
                                     linear-gradient(to right, rgba(0,0,0,0.05) 1px, transparent 1px),
                                     linear-gradient(to bottom, rgba(0,0,0,0.05) 1px, transparent 1px)
                                 `,
                                backgroundSize: `${CELL_WIDTH}px ${CELL_HEIGHT}px`
                            }}
                        />

                        {/* Edges Layer */}
                        <svg className="absolute top-0 left-0 w-full h-full pointer-events-none" style={{ zIndex: 10, overflow: 'visible' }}>
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#9ca3af" />
                                </marker>
                            </defs>
                            {renderEdges}
                        </svg>

                        {/* Nodes */}
                        {Object.entries(layout.nodes).map(([name, pos]) => {
                            const data = maps.find(m => m.name === name);
                            if (!data) return null;

                            const pixel = getPixelCoords(pos.gridX, pos.gridY);
                            const isDraggingThis = dragItem?.type === 'node' && dragItem.id === name;



                            return (
                                <div
                                    key={name}
                                    className={clsx(
                                        "absolute flex flex-col bg-surface border rounded-xl overflow-visible shadow-sm hover:shadow-xl transition-shadow group/card",
                                        data.type === 'modal' ? 'border-dashed border-tertiary' : 'border-outline-variant/60',
                                        isDraggingThis ? 'z-50 ring-2 ring-primary shadow-2xl opacity-90' : 'z-20'
                                    )}
                                    style={{
                                        left: pixel.x,
                                        top: pixel.y,
                                        width: NODE_WIDTH,
                                        height: NODE_HEIGHT,
                                        cursor: isDraggingCanvas ? 'move' : 'grab'
                                    }}
                                    onMouseDown={(e) => {
                                        e.stopPropagation();
                                        setDragItem({ type: 'node', id: name });
                                    }}
                                >
                                    {/* Content */}
                                    <div className="h-48 w-full bg-surface-variant/20 relative overflow-hidden flex items-center justify-center p-2 pointer-events-none rounded-t-xl">
                                        {data.base64_preview ? (
                                            <img src={`data:image/png;base64,${data.base64_preview}`} className="max-h-full max-w-full object-contain shadow-sm rounded" />
                                        ) : (
                                            <span className="text-xs text-on-surface-variant/50">No Preview</span>
                                        )}
                                        <div className="absolute top-2 right-2 px-1.5 py-0.5 rounded bg-black/60 text-[10px] text-white backdrop-blur-sm">
                                            {data.type}
                                        </div>
                                    </div>
                                    <div className="flex-1 p-3 flex flex-col justify-center border-t border-outline-variant/10 bg-surface rounded-b-xl pointer-events-none">
                                        <div className="flex items-center justify-between gap-2 pointer-events-auto">
                                            <h3 className="font-semibold text-sm text-on-surface truncate" title={data.name}>
                                                {data.name}
                                            </h3>
                                            {onEditScreen && (
                                                <button
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        onEditScreen(data.name);
                                                        onClose();
                                                    }}
                                                    className="p-1.5 hover:bg-primary/10 text-on-surface-variant hover:text-primary rounded-full transition-all"
                                                    title={t('mapper.action.edit')}
                                                >
                                                    <Pencil size={14} />
                                                </button>
                                            )}
                                        </div>
                                        <div className="text-xs text-on-surface-variant/70 mt-1 pointer-events-auto">
                                            {data.elements.length} {t('mapper.elements', 'elements')}
                                        </div>
                                    </div>

                                    {/* Ports Layer (Moved to end and pointer-events-auto) */}
                                    <div className="absolute inset-0 pointer-events-none" style={{ zIndex: 100 }}>
                                        {NODE_PORTS.map(p => {


                                            // Correct Layout-Based Occupancy Check
                                            const isTrulyOccupied = Object.entries(layout.edges).some(([eKey, edge]) => {
                                                const [sName, _, tName] = eKey.split('-'); // rudimentary parsing
                                                if (sName === name && edge.sourceHandle === p.id) return true;
                                                if (tName === name && edge.targetHandle === p.id) return true;
                                                return false;
                                            });

                                            // Allow hovering if occupied ONLY if we are moving the connection FROM this port?
                                            // Or just show red if occupied?
                                            // User said: "Ports cannot be occupied by more than one arrow."

                                            // If I am dragging an edge end, and I hover an occupied port, I should block it or show error.

                                            const isHovered = hoveredPort?.nodeId === name && hoveredPort?.portId === p.id;
                                            const showPorts = (dragItem?.type === 'source' || dragItem?.type === 'target');

                                            // If not showing ports and not occupied, hide.
                                            // If occupied, maybe show a small dot usually? Or only when trying to connect?

                                            // Style:
                                            // Occupied: Gray/Filled dot?
                                            // dragging: Show available as open rings, occupied as X?

                                            return (
                                                <div
                                                    key={p.id}
                                                    className={clsx(
                                                        "absolute w-4 h-4 rounded-full border border-solid transition-all pointer-events-auto flex items-center justify-center",
                                                        isTrulyOccupied
                                                            ? (showPorts ? "bg-error/20 border-error" : "bg-outline-variant/50 border-transparent scale-50 opacity-0 group-hover/card:opacity-100")
                                                            : (showPorts || isHovered)
                                                                ? "bg-surface border-outline-variant opacity-100 scale-100"
                                                                : "opacity-0 scale-0",
                                                        isHovered && !isTrulyOccupied && "bg-primary border-primary scale-125 z-50",
                                                        isHovered && isTrulyOccupied && "cursor-not-allowed"
                                                    )}
                                                    style={{
                                                        left: p.x - 8,
                                                        top: p.y - 8
                                                    }}
                                                    onMouseEnter={() => setHoveredPort({ nodeId: name, portId: p.id })}
                                                    onMouseLeave={() => setHoveredPort(null)}
                                                    onMouseUp={(e) => {
                                                        e.stopPropagation();
                                                        if (isTrulyOccupied) return; // Prevent drop
                                                        // Handled by global mouseUp
                                                    }}
                                                >
                                                    {isTrulyOccupied && showPorts && <div className="w-1.5 h-1.5 rounded-full bg-error" />}
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            </div>
        </div>,
        document.body
    );
}
